#+title: Aliases for Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

Implementation of aliases for [[http://elvish.io][Elvish]].

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[alias.elv][alias.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]
  - [[#loading-libraries][Loading libraries]]
  - [[#configuration][Configuration]]
  - [[#creating-aliases][Creating aliases]]
  - [[#exporting-aliases][Exporting aliases]]
  - [[#listing-aliases][Listing aliases]]
  - [[#removing-aliases][Removing aliases]]
  - [[#load-time-initialization][Load-time initialization]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/alias
#+end_src

To define an alias:

#+begin_src elvish
  alias:new alias command
#+end_src

Note that due to Elvish's scoping rules, if you want to use a module
from your alias, you need to load the module as well, e.g. something
like this:

#+begin_src elvish
  alias:new cd "use github.com/zzamboni/elvish-modules/dir; dir:cd"
#+end_src

You can also use =alias:bash-alias= to use the bash syntax
=alias=command= for defining aliases.

Once an alias is defined, it does not become immediately available -
you need to load and activate them by adding the following line to the
end of your =rc.elv= file:

#+begin_src elvish
  -exports- = (alias:export)
#+end_src

(if you are putting other things in =$-exports-= you need to merge it
with the output of =alias:export=, instead of just assigning it)

Each alias is stored in a separate file under =$alias:dir=
(=~/.elvish/aliases/= by default).

To list existing aliases:

#+begin_src elvish
  alias:list
#+end_src

To remove an alias:

#+begin_src elvish
  alias:rm alias
#+end_src

The alias is not removed from the current session, it will take effect
in new sessions, or you can remove it by hand by running =del
$aliasname~=.

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

#+begin_src elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/elvish-modules/blob/master/alias.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

** Loading libraries

#+begin_src elvish
  use re
#+end_src

** Configuration

The =alias:dir= variable determines where the alias files will be saved.

#+begin_src elvish
  dir = ~/.elvish/aliases
#+end_src

** Creating aliases

Aliases are defined as functions, which execute the body provided as
the alias definition. After writing the file we load it with the
=-source= command to load it into the =$alias:aliases= map, where they are
kept indexed by alias name.

#+begin_src elvish
  aliases = [&]
#+end_src

#+begin_src elvish
  fn _load_alias [name file]{
    -alias = [&]
    -source $file
    -tmpfile = (mktemp)
    echo '-alias['$name'] = $'$name'~' > $-tmpfile
    -source $-tmpfile
    rm -f $-tmpfile
    aliases[$name] = $-alias[$name]
  }
#+end_src

#+begin_src elvish
  fn def [&verbose=false name @cmd]{
    file = $dir/$name.elv
    echo "#alias:new" $name $@cmd > $file
    echo 'fn '$name' [@_args]{' $@cmd '$@_args }' >> $file
    if (not-eq $verbose false) {
      echo (edit:styled "Defining alias "$name green)
    }
    _load_alias $name $file
  }
#+end_src

=alias:new= is equivalent to =alias:def=.

#+begin_src elvish
  fn new [@arg]{ def $@arg }
#+end_src

The =alias:bash-alias= command simply splits the arguments on the first
equals sign, and calls =alias:def= with the two pieces.

#+begin_src elvish
  fn bash-alias [@args]{
    line = $@args
    name cmd = (splits &max=2 '=' $line)
    def $name $cmd
  }
#+end_src

** Exporting aliases

In order for aliases to be loaded from =rc.elv=, they need to be
exported and assigned to the special =$-exports-= variable. The
=alias:export= function returns a map that can be assigned or merged
into =$-exports-=.

We cannot simply export =$alias:aliases= because function variables need
to have =~= appended at the end of the keys, for them to be usable as
functions when exported.

#+begin_src elvish
  fn export {
    result = [&]
    keys $aliases | each [k]{
      result[$k"~"] = $aliases[$k]
    }
    put $result
  }
#+end_src

** Listing aliases

To list aliases, we grep the aliases directory for the corresponding
definition files. Each file has a marker at the beginning which
includes the alias definition command. =alias:list= and =alias:ls= are
equivalent.

#+begin_src elvish
  fn list {
    _ = ?(grep -h '^#alias:new ' $dir/*.elv | sed 's/^#//')
  }

  fn ls { list } # Alias for list
#+end_src

** Removing aliases

Removing an alias is achieved by removing its definition
file. =alias:rm= and =alias:undef= are equivalent.

Alias removals do not take care in the current session, unless you
manually remove them with the =del= command.

#+begin_src elvish
  fn undef [name]{
    file = $dir/$name.elv
    if ?(test -f $file) {
      # Remove the definition file
      rm $file
      echo (edit:styled "Alias "$name" removed (will take effect on new sessions, or when you run 'del "$name"~')." green)
    } else {
      echo (edit:styled "Alias "$name" does not exist." red)
    }
  }

  fn rm [@arg]{ undef $@arg }
#+end_src

** Load-time initialization

The =init= function is run automatically when the module is loaded. It
creates the alias directory if needed, and loads all the existing
alias files. Note that this does not export the functions, you need to
use =alias:export= from your =rc.elv= for that.

We do on-the-fly conversion of old-style alias files into the new
format, which includes the assignment to =$alias= elements in the
file. Old-style files are identified because they contain a header
with =#alias:def=, where new ones contain =#alias:new=.

#+begin_src elvish
  fn init {
    if (not ?(test -d $dir)) {
      mkdir -p $dir
    }

    for file [(_ = ?(put $dir/*.elv))] {
      content = (cat $file | slurp)
      if (or (re:match '^#alias:def ' $content) (re:match '\nalias\[' $content)) {
        m = (re:find '^#alias:(def|new) (\S+)\s+(.*)\n' $content)[groups]
        new $m[2][text] $m[3][text]
      } elif (re:match '^#alias:new ' $content) {
        name = (re:find '^#alias:new (\S+)\s+(.*)\n' $content)[groups][1][text]
        _load_alias $name $file
      }
    }
  }

  init
#+end_src
