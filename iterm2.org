#+title: iTerm2 shell integration for Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+name: module-summary
This library implements iTerm2's [[https://iterm2.com/documentation-shell-integration.html][Shell Integration]] for Elvish.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:util.elv][util.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]
  - [[#base-escape-sequences][Base escape sequences]]
  - [[#iterm2-commands][iTerm2 commands]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/iterm2
#+end_src

After you load it, the following [[https://iterm2.com/documentation-shell-integration.html][Shell Integration]] features will be available:

- Marks :: a mark is automatically added at each command prompt. Marks are indicated by a small blue triangle in the left margin, like this (example shows my [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org][Chain]] theme):

  [[file:images/iterm2-marks.jpg]]

  You can also manually produce a mark by calling =iterm2:mark=:

  [[file:images/iterm2-marks2.jpg]]

-  ::



* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

The escape sequences used by iTerm2 for shell integration are described in detail in the [[https://www.iterm2.com/documentation-escape-codes.html][Proprietary Escape Codes]] documentation.

** Base escape sequences

All escape sequences have the same basic sequence: start with an ESC character (=\e=) followed by =]=, semi-colon separated components, and ending with a BEL character (=\a=). The =iterm2:mk-escape-str= builds such a string, using its arguments for the components.

#+begin_src elvish
  fn mk-escape-str [xs]{ put "\e]"(joins ';' $xs)"\a" }
  #+end_src

The =iterm2:escape-cmd= calls =iterm2:mk-escape-str= and prints the result.

#+begin_src elvish
  fn escape-cmd [xs]{
    print (mk-escape-str $xs)
  }
#+end_src

Two types of escape sequences are used: custom iTerm2 commands start with =1337=, and the "FinalTerm" commands used for the basic shell integration start with =133=. These two sequences are produced by =iterm2:mk-iterm2-cmd= and =iterm2:mk-ftcs-cmd=, respectively.

  #+begin_src elvish
  fn mk-iterm2-cmd [@x]{ mk-escape-str [1337 $@x] }
  fn mk-ftcs-cmd [@x]{ mk-escape-str [133 $@x] }
  #+end_src

iTerm2 commands come in two types: plain commands and "set" commands, which assign a value. We have two functions to emit these as needed.

  #+begin_src elvish
  fn cmd [@x]{ print (mk-iterm2-cmd $@x) }
  fn set [@x]{ print (mk-iterm2-cmd (joins '=' $x)) }
  #+end_src

** iTerm2 commands

Make the terminal report the foreground and background colors

#+begin_src elvish
  fn background-color {
    print (mk-escape-str [4 -2 '?'])
  }

  fn foreground-color {
    print (mk-escape-str [4 -1 '?'])
  }
#+end_src

Produce a hyperlink in the terminal. =params= if given, should be a map containing key/value pairs (the only supported param at the moment is =id=). This function does not print the string, you need to do that with =print= or =echo=, e.g.:

#+begin_src elvish :tangle no
  echo "This is" (iterm2:hyperlink http://zzamboni.org "my website")
#+end_src

#+begin_src elvish
  fn hyperlink [url text &params=[&]]{
    params-str = ""
    if (not-eq $params [&]) {
      params-str = (joins ":" (each [k]{ print $k"="$params[$k] } [(keys $params)]))
    }
    put (mk-escape-str [ '8' $params-str $url ])$text(mk-escape-str [ '8' '' ''])
  }
#+end_src

Setting a mark at the current position.

#+begin_src elvish
  fn mark { cmd SetMark }
#+end_src

Bring iTerm2 to the foreground.

#+begin_src elvish
  fn focus { cmd StealFocus }
#+end_src

Inform iTerm2 of the current directory. This is a wrapper around =iterm2:set CurrentDir=, but we have a dedicated function because it's commonly used.

#+begin_src elvish
  fn setdir [d]{
    set CurrentDir $d
  }
#+end_src

Post a notification through iTerm2.

#+begin_src elvish
  fn notify [msg]{
    print (mk-escape-str [9 $msg])
  }
#+end_src

Copy to clipboard. Everything displayed in the terminal between calling =iterm2:startcopy= and =iterm2:endcopy= is copied to the clipboard. The general clipboard is used by default, but an option =&name= can be passed to =iterm2:startcopy= with values =rule=, =find= or =font= (not sure what each does, but they are mentioned in the iTerm2 documentation).

#+begin_src elvish
  fn startcopy [&name=""]{
    set CopyToClipboard $name
  }

  fn endcopy {
    cmd EndCopy
  }
#+end_src

If you want to put a stored string in the clipboard, you can use =iterm2:copystr=.

#+begin_src elvish
  fn copystr [s]{
    encoded-str = (print $s | /usr/bin/base64)
    set Copy :$encoded-str
  }
#+end_src

Set window title and tab background color. Arguments are the red, green and blue values. =iterm2:reset-title-color= resets to the default.

#+begin_src elvish
  fn set-title-color [r g b]{
    escape-cmd [6 1 bg red brightness $r]
    escape-cmd [6 1 bg green brightness $g]
    escape-cmd [6 1 bg blue brightness $b]
  }

  fn reset-title-color {
    escape-cmd [6 1 bg '*' default]
  }
#+end_src

Set an annotation at the current position. By default, the annotation covers the whole line where the cursor is, and its label is shown immediately. The following options are supported:

- ~&hidden~ :: the label is not shown immediately;
- ~&length=n~ :: length of the annotation;
- ~&xy=[x y]~ :: position of the annotation. If =&xy= is specified, =&length= must ber specified as well.

#+begin_src elvish
  fn annotate [ann &hidden=$false &length=$nil &xy=$nil]{
    parts = [ $ann ]
    if (and $length $xy) {
      parts = [ $ann $length $@xy ]
    } elif (and $length (not $xy)) {
      parts = [ $length $ann ]
    }
    cmd = AddAnnotation
    if $hidden { cmd = AddHiddenAnnotation }
    cmd $cmd=(joins "|" $parts)
  }
#+end_src

Change color palette. See [[https://www.iterm2.com/documentation-escape-codes.html][the documentation]] for the possible =key= values.

#+begin_src elvish
  fn setcolor [key r g b]{
    set SetColors $key (printf %02x%02x%02x $r $g $b)
  }
#+end_src

Change profile.

#+begin_src elvish
  fn profile [p]{ set SetProfile $p }
#+end_src

Set background image. Without an argument, the background image is removed.

#+begin_src elvish
  fn setbackground [@file]{
    encoded-file = ""
    if (not-eq $file []) {
      encoded-file = (print $file[0] | /usr/bin/base64)
    }
    set SetBackgroundImageFile $encoded-file
  }
#+end_src

Set iTerm2 user variables.

#+begin_src elvish
  fn setuservar [var val]{
    set SetUserVar $var (print $val | /usr/bin/base64)
  }
#+end_src

Set the badge on the terminal.

  #+begin_src elvish
    fn setbadge [@badge]{
      set SetBadgeFormat (print $@badge | /usr/bin/base64)
    }
  #+end_src

Some of the less-common commands can be invoked through the =iterm2:cmd= or =iterm2:set= commands:

- Set cursor shape :: =iterm2:set CursorShape $shape=, where =$shape= can indicate a block (0), vertical bar (1) or underline (2).
- Clear scrollback history :: =iterm2:cmd ClearScrollback=.
- Enable/disable cursor guide :: =iterm2:set HighlightCursorLine yes/no=.
- Request attention :: =iterm2:set RequestAttention value=. Possible values are =yes=, =once=, =no= and =fireworks=.
- Report cell size :: =iterm2:cmd ReportCellSize=.
- Set function key labels :: =iterm2:set SetKeyLabel $key $label=.

#+begin_src elvish
  edit:before-readline = [{ mark } $@edit:before-readline]
  fn windowtitle [t]{ print "\e]0;"$t"\a" }
  paths = [ $@paths ~/.iterm2 ]
#+end_src
