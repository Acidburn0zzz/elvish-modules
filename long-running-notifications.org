#+title: Notifications for long-running commands in Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

Produce notifications for long-running commands in Elvish.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[file:long-running-notifications.elv][long-running-notifications.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
  - [[#notification-mechanisms][Notification mechanisms]]
- [[#implementation][Implementation]]
  - [[#configuration-and-user-accessible-variables][Configuration and user-accessible variables]]
  - [[#notification-mechanisms-1][Notification mechanisms]]
  - [[#other-functions][Other functions]]
  - [[#initialization][Initialization]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/long-running-notifications
#+end_src

Try it out! Run the following command:

#+begin_src elvish
  sleep 11
#+end_src

The default notification threshold is 10 seconds, so when the command
finishes, you will see a notification. The threshold can be changed by
assigning a value in seconds to the =long-running-notifications:threshold=
variable. For example:

#+begin_src elvish
  long-running-notifications:threshold = 20
#+end_src

** Notification mechanisms

By default, the module tries to determine the best notification method
to use based on available commands. The method can be specified
manually by assigning one of the following values directly to
=$long-running-notifications:notifier=:

- A string, which must be one of the predefined notification
  mechanisms:
  - =macos= (GUI notifications on macOS, used automatically if
    [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] is available)
  - =text= (prints to the same terminal where the command ran)

- A lambda, which must take three arguments and produce the
  corresponding notification. The arguments contain the last command
  (string), its duration (in seconds) and its start time (as seconds
  in Unix epoch format). For example:

  #+begin_src elvish
    long-running-notifications:notifier = [cmd duration start]{
      echo "LONG COMMAND! Lasted "$duration
    }
  #+end_src

If you write a new notification mechanism which you think might be
useful to others, please submit a [[https://github.com/zzamboni/elvish-modules/pulls][pull request]]!

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

** Configuration and user-accessible variables

Threshold in seconds for producing notifications (default 10).

#+BEGIN_SRC elvish
  threshold=10
#+END_SRC

Variables which can be used to extract information about the last command executed.

#+BEGIN_SRC elvish
  last_cmd_start_time = 0
  last_cmd = ""
  last_cmd_duration = 0
#+END_SRC

The =$notifier= variable determines which notification mechanism to
use. By default it starts with the value ="auto"= which tells the =init=
function that it should choose which one to use automatically, based
on the value of =$notifications-to-try= (see below). But you can also
hand-choose the method by assigning one of the following:

- A string, which must be one of the predefined notification
  mechanisms (at the moment =text= or =macos=).
- A lambda, which must take three arguments and produce the
  corresponding notification. The arguments contain the last command
  (string), its duration (in seconds) and its start time (as seconds
  in Unix epoch format).

#+begin_src elvish
  notifier = auto
#+end_src

The =$notifications-to-try= variable contains the order in which
notification mechanisms should be attempted. For each one, their =check=
function is executed, and the first one for which it returns =$true= is
used.

#+begin_src elvish
  notifications-to-try = [ macos text ]
#+end_src

** Notification mechanisms

Each notification mechanism is defined as a map with two elements:
=check= should be a lambda which returns =$true= if that mechanism can
be used in the current session, and =notify= must be a lambda which
receives three arguments: the command (string), its duration (in
seconds) and its start time (as seconds in Unix epoch format).

All notification mechanisms are stored in the =notification_fns= map, by
their user-visible name.

#+begin_src elvish
  notification_fns = [
    &text= [
      &check= { put $true }
      &notify= [cmd dur start]{
        echo (edit:styled "Command lasted "$dur"s" magenta)
      }
    ]
    &macos= [
      &check= { put ?(which terminal-notifier >/dev/null 2>&1) }
      &notify= [cmd duration start]{
        terminal-notifier -title "Finished: "$cmd -message "Running time: "$duration"s"
      }
    ]
  ]
#+end_src

The =-choose-notification-fn= goes through the notification mechanisms
in the order defined by =$notifications-to-try= and chooses which one to
use.

#+begin_src elvish
  fn -choose-notification-fn {
    each [method_name]{
      method = $notification_fns[$method_name]
      if ($method[check]) {
        put $method[notify]
        return
      }
    } $notifications-to-try
    fail "No valid notification mechanism was found"
  }
#+end_src

** Other functions

These are the main functions which keep track of how long a command
takes and call the notifier function if needed.

Return the current time in Unix epoch value.

#+BEGIN_SRC elvish
  fn now {
    put (date +%s)
  }
#+END_SRC

Check the duration of the last command and produce a notification if
it exceeds the threshold.

#+BEGIN_SRC elvish
  fn before_readline_hook {
    _end_time = (now)
    last_cmd_duration = (- $_end_time $last_cmd_start_time)
    if (> $last_cmd_duration $threshold) {
      $notifier $last_cmd $last_cmd_duration $last_cmd_start_time
    }
  }
#+END_SRC

Record the command and its start time.

#+BEGIN_SRC elvish
  fn after_readline_hook [cmd]{
    last_cmd = $cmd
    last_cmd_start_time = (now)
  }
#+END_SRC

** Initialization

The =init= function sets up the notifier function and also the prompt
hooks to compute times and produce notifications as needed.

Note: if you modify the value of =$notifier=, you need to call =init= again.

#+BEGIN_SRC elvish
  fn init {
    # First choose the notification mechanism to use
    if (eq $notifier auto) {
      notifier = (-choose-notification-fn)
    } elif (has-key $notification_fns $notifier) {
      notifier = $notification_fns[$notifier]
    } elif (not-eq (kind-of $notifier fn)) {
      fail "Invalid value for $long-running-notifications:notifier: "$notifier", please double check"
    }
    # Then set up the hooks
    use ./prompt_hooks
    prompt_hooks:add-before-readline $before_readline_hook~
    prompt_hooks:add-after-readline $after_readline_hook~
    # Initialize to avoid spurious notification when the module is loaded
    last_cmd_start_time = (now)
  }
#+END_SRC

We call =init= automatically on module load.

#+begin_src elvish
  init
#+end_src
