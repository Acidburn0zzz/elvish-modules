#+TITLE:  Semantic version comparison functions for Elvish
#+AUTHOR: Diego Zamboni
#+EMAIL:  diego@zzamboni.org

This module implements comparison of semantic version numbers, as described in [[https://semver.org/#spec-item-11][the Semantic Versioning specification]].

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:$name.elv][$name.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/semver
#+end_src

The =semver:cmp= function receives two version numbers and returns -1, 0 or 1 depending on whether the first version number is older, the same or newer than the second. It uses the rules as described in [[https://semver.org/#spec-item-11][the Semantic Versioning specification]].

#+begin_src elvish :exports both :use github.com/zzamboni/elvish-modules/semver
  vers = [
    1.0.1 1.0 1.0.0 2.0.0 2.1.0 2.1.1 1.0.0-alpha
    1.0.0-alpha.beta 1.0.0-alpha.1 1.0.0-beta
    1.0.0-beta.2 1.0.0-beta.11 1.0.0-rc.1 1.0.0 1.0 1
  ]
  range (- (count $vers) 1) | each [i]{
    v1 v2 = $vers[$i (+ $i 1)]
    echo semver:cmp $v1 $v2
    semver:cmp $v1 $v2
  }
#+end_src

#+RESULTS:
#+begin_example
semver:cmp 1.0.1 1.0
▶ -1
semver:cmp 1.0 1.0.0
▶ 0
semver:cmp 1.0.0 2.0.0
▶ 1
semver:cmp 2.0.0 2.1.0
▶ 1
semver:cmp 2.1.0 2.1.1
▶ 1
semver:cmp 2.1.1 1.0.0-alpha
▶ -1
semver:cmp 1.0.0-alpha 1.0.0-alpha.beta
▶ 1
semver:cmp 1.0.0-alpha.beta 1.0.0-alpha.1
▶ -1
semver:cmp 1.0.0-alpha.1 1.0.0-beta
▶ 1
semver:cmp 1.0.0-beta 1.0.0-beta.2
▶ 1
semver:cmp 1.0.0-beta.2 1.0.0-beta.11
▶ 1
semver:cmp 1.0.0-beta.11 1.0.0-rc.1
▶ 1
semver:cmp 1.0.0-rc.1 1.0.0
▶ 1
semver:cmp 1.0.0 1.0
▶ 0
semver:cmp 1.0 1
▶ 0
#+end_example

The =semver:eq=, =semver:not-eq=, =semver:<=, =semver:<==, =semver:>= and =semver:>== functions behave just like their [[https://elvish.io/ref/builtin.html#section-3][numeric or string versions]], but with version numbers. They all use =semver:cmp= to do the comparison.

#+begin_src elvish :exports both :use github.com/zzamboni/elvish-modules/semver
semver:<      1.0.0 2.0.0 2.1.0
semver:<      1.0.0-alpha 1.0.0 2.1.0
semver:<=     1.0.0 1.0.0 2.1.0
semver:>      1.0.0 1.0.0-rc1 0.9.0
semver:>=     1.0.0-rc1 1.0.0-rc1 0.9.0
semver:eq     1.0.0 1.0 1
semver:not-eq 1.0.0 1.0 1
semver:not-eq 1.0.0 1.0.1 2.0.0
#+end_src

#+RESULTS:
: ▶ $true
: ▶ $true
: ▶ $true
: ▶ $true
: ▶ $true
: ▶ $true
: ▶ $false
: ▶ $true


* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

#+begin_src elvish
  use re
  use builtin
  use ./util

  fn -signed-compare [ltfn v1 v2]{
    if     ($ltfn $v1 $v2) { put  1
    } elif ($ltfn $v2 $v1) { put -1
    } else                 { put  0 }
  }

  fn -num-str-cmp [e1 e2]{
    lt = $<s~
    if (re:match '^\d+$' $e1$e2) { lt = $<~ }
    -signed-compare $lt $e1 $e2
  }

  fn -part-compare [v1 v2]{
    v1s = [(splits '.' $v1)]
    v2s = [(splits '.' $v2)]
    num = (util:max (count $v1s) (count $v2s))
    fill = [(repeat $num 0)]
    range $num | each [i]{
      comp = (-num-str-cmp [$@v1s $@fill][$i] [$@v2s $@fill][$i])
      if (!= $comp 0) {
        put $comp
        return
      }
    }
    put 0
  }

  fn cmp [v1 v2]{
    rel1 prerel1 @_ = (splits '-' $v1) $false
    rel2 prerel2 @_ = (splits '-' $v2) $false
    comp = (-part-compare $rel1 $rel2)
    if (!= $comp 0) {
      put $comp
    } else {
      if (and $prerel1 $prerel2) {
        -part-compare $prerel1 $prerel2
      } else {
        -signed-compare [v1 v2]{ and $v1 (not $v2) } $prerel1 $prerel2
      }
    }
  }
#+end_src

#+begin_src elvish
  fn -seq-compare [op expected @vers]{
    res = $true
    last = $false
    each [v]{
      if $last {
        res = (and $res ($op (cmp $last $v) $expected))
      }
      last = $v
    } $vers
    put $res
  }
#+end_src

#+begin_src elvish
  fn '<' [@vers]{
    -seq-compare $builtin:eq~ 1 $@vers
  }

  fn '>' [@vers]{
    -seq-compare $builtin:eq~ -1 $@vers
  }

  fn eq [@vers]{
    -seq-compare $builtin:eq~ 0 $@vers
  }

  fn not-eq [@vers]{
    -seq-compare $builtin:not-eq~ 0 $@vers
  }

  fn '<=' [@vers]{
    -seq-compare $builtin:not-eq~ -1 $@vers
  }

  fn '>=' [@vers]{
    -seq-compare $builtin:not-eq~ 1 $@vers
  }
#+end_src
