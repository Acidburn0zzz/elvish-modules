#+TITLE:  Test framework for Elvish
#+AUTHOR: Diego Zamboni
#+EMAIL:  diego@zzamboni.org

A very simplistic test framework for Elvish.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:test.elv][test.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/test
#+end_src

The basic block is =test:is=. It takes a lambda and an optional description, and returns a function which executes the lambda, and reports the test as passed if it returns a booleanly true value. The description, if given, is printed together with the results.

Note that =test:is= returns a function, so to actually run the test, you need to execute its result by enclosing the call in parenthesis (this is so that test functions can be aggregated using =test:set=, see below).

#+begin_src elvish :use github.com/zzamboni/elvish-modules/test :exports both
(test:is { eq ( + 2 2 ) 4 } True arithmetic)
(test:is { eq ( + 2 2 ) 5 } Funky arithmetic)
#+end_src

#+RESULTS:
: OK True arithmetic  eq ( + 2 2 ) 4
: FAIL Funky arithmetic  eq ( + 2 2 ) 5
:     actual: $false

Tests can be grouped using =test:set=, which takes an identifier and a list of test functions, which get executed in sequence. =test:set= objects can be nested.

#+begin_src elvish :use github.com/zzamboni/elvish-modules/test,github.com/zzamboni/elvish-modules/util :exports both
  (test:set github.com/zzamboni/elvish-modules/util \
    (test:set dotify-string \
      (test:is { eq (util:dotify-string "somelongstring" 5) "somel…" } Long string gets dotified) \
      (test:is { eq (util:dotify-string "short" 5) "short" } Equal-as-limit string stays the same) \
      (test:is { eq (util:dotify-string "bah" 5) "bah" } Short string stays the same)))
#+end_src

#+RESULTS:
: Testing github.com/zzamboni/elvish-modules/util
: Testing github.com/zzamboni/elvish-modules/util dotify-string
: OK Long string gets dotified  eq (util:dotify-string "somelongstring" 5) "somel…"
: OK Equal-as-limit string stays the same  eq (util:dotify-string "short" 5) "short"
: OK Short string stays the same  eq (util:dotify-string "bah" 5) "bah"


* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

=test:is= takes a lamda, and returns a function which verifies that the output of the lambda is true. Optionally a description of the test can be passed, which gets printed together with the result of the test.

#+begin_src elvish
  fn is [f @d]{
    put [&top-id='']{
      msg = ""
      if (> (count $d) 0) {
        msg = (styled (joins " " $d) blue)
      }
      res = ($f)
      if $res {
        echo (styled "OK" green) $msg $f[body]
      } else {
        echo (styled "FAIL" red) $msg $f[body]
        echo "    actual: "(to-string $res)
      }
    }
  }
#+end_src

=test:set= receives a description and a set of test functions (can be either other =test:set= or =test:is=), and returns a function which calls them in sequence. A header with the description is printed. In nested =test:set= objects, the description of the enclosing set gets prepended, separated by a space.

#+begin_src elvish
  fn set [id @tests]{
    put [&top-id=""]{
      if (not-eq $top-id '') {
        id = $top-id' '$id
      }
      echo (styled "Testing "$id blue)
      each [t]{ $t &top-id=$id } $tests
    }
  }
#+end_src
