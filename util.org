#+title: Miscellaneous utility functions for Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This module includes various utility functions.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[file:util.elv][util.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
  - [[#dotifying-strings][Dotifying strings]]
  - [[#parallel-redirection-of-stdoutstderr-to-different-commands][Parallel redirection of stdout/stderr to different commands]]
  - [[#evaluating-code][Evaluating code]]
  - [[#yes-or-no-prompts][Yes-or-no prompts]]
- [[#implementation][Implementation]]
  - [[#dotifying-strings-1][Dotifying strings]]
  - [[#parallel-redirection-of-stdoutstderr-to-different-commands-1][Parallel redirection of stdout/stderr to different commands]]
  - [[#evaluating-code-1][Evaluating code]]
  - [[#yes-or-no-prompts-1][Yes-or-no prompts]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/util
#+end_src

The following functions are included:

** Dotifying strings

=util:dotify-string= shortens a string to a maximum length, followed by
dots.

#+begin_src elvish :use github.com/zzamboni/elvish-modules/util
util:dotify-string somelongstring 5
#+end_src

#+RESULTS:
: ▶ somel…

** Parallel redirection of stdout/stderr to different commands

=util:pipesplit= does parallel redirection of stdout and stderr to
different commands. It takes three lambdas: The first one is executed,
its stdout is redirected to the second one, and its stderr to the
third one.

#+begin_src elvish :use github.com/zzamboni/elvish-modules/util
  util:pipesplit { echo stdout-test; echo stderr-test >&2 } { echo STDOUT: (cat) } { echo STDERR: (cat) }
#+end_src

#+RESULTS:
: STDOUT: stdout-test
: STDERR: stderr-test

** Evaluating code

=util:eval= does dynamic evaluation of code. Note that due to Elvish's
scoping rules, statements are evaluated within the context of the =util=
module, so variable assignments will not be persistent. Also, if you
need to make use of any modules within the code, you need to
explicitly load them with =use=.

#+begin_src elvish :exports both :use github.com/zzamboni/elvish-modules/util
  util:eval "put foo"
#+end_src

#+RESULTS:
: ▶ foo

** Yes-or-no prompts

=y-or-n= receives a prompt string, shows the prompt to the user and
accepts =y= or =n= as an answer. Returns =$true= if the user responds with
=y=. The =&style= option can be used to specify the style for the prompt,
as accepted by [[https://elvish.io/ref/edit.html#editstyled][edit:styled]].

#+begin_src elvish
  [~]─> util:y-or-n "Do you agree?"
  Do you agree? [y/n] y
  ▶ $true
  [~]─> util:y-or-n &style=red "Is this green?"
  Is this green? [y/n] n
  ▶ $false
#+end_src

Typical use is as part of an =if= statement:

#+begin_src elvish
  [~]─> if (util:y-or-n "Are you OK?") { echo "Great!" }
  Are you OK? [y/n] y
  Great!
#+end_src

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

#+begin_src elvish
  use re
#+end_src

** Dotifying strings

#+begin_src elvish
  fn dotify-string [str dotify-length]{
    if (or (== $dotify-length 0) (<= (count $str) $dotify-length)) {
      put $str
    } else {
      re:replace '(.{'$dotify-length'}).*' '$1…' $str
    }
  }
#+end_src

** Parallel redirection of stdout/stderr to different commands

The implementation of this function was inspired by the discussion [[https://github.com/elves/elvish/issues/500][in this issue]].

#+begin_src elvish
  fn pipesplit [l1 l2 l3]{
    pout = (pipe)
    perr = (pipe)
    run-parallel {
      $l1 > $pout 2> $perr
      pwclose $pout
      pwclose $perr
    } {
      $l2 < $pout
      prclose $pout
    } {
      $l3 < $perr
      prclose $perr
    }
  }
#+end_src

** Evaluating code

Elvish does not include an =eval= function, but we emulate one using the
=-source= command.

#+begin_src elvish
  fn eval [str]{
    tmpf = (mktemp)
    echo $str > $tmpf
    -source $tmpf
    rm -f $tmpf
  }
#+end_src

** Yes-or-no prompts

#+begin_src elvish
  fn y-or-n [&style=default prompt]{
    prompt = $prompt" [y/n] "
    if (not-eq $style default) {
      prompt = (edit:styled $prompt $style)
    }
    print $prompt > /dev/tty
    resp = (head -n1 < /dev/tty)
    eq $resp y
  }
#+end_src
